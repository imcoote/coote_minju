"""*******************************************************************************
 * 소요시간: 5시간
 * 시간복잡도: O(N)
 * 메모리: 32544 kb
 * 시간: 44 ms
 *******************************************************************************"""
def can_win_stones(N):
    # 처음 4개의 돌 개수에 대한 승패 기록 (1: 상근 승, 0: 창영 승)
    # dp[1] = 상근이 1개 가져가서 승리
    # dp[2] = 상근이 1개 가져가면 창영이 1개 가져가서 패배
    # dp[3] = 상근이 3개 가져가서 승리
    # dp[4] = 상근이 4개 가져가서 승리
    win = [1, 0, 1, 1]  # dp[1]-dp[4]

    # 돌이 4개 이하일 경우, 미리 저장된 결과를 반환
    if N <= 4:
        return "SK" if win[N-1] else "CY"

    # 돌 개수가 5개 이상인 경우 "슬라이딩 윈도우" 방식으로 계산
    for i in range(5, N + 1):
        # 현재 돌 개수 N에서 상근이가 이기려면 창영이가 질 수밖에 없는 경우를 만들 수 있어야 함
        # 즉, N-1, N-3, N-4 개의 돌 상태 중 하나라도 창영이가 지는 상태(0)라면 상근이가 승리
        next_state = not (win[-1] and win[-3] and win[-4])

        # 가장 오래된 상태를 제거하고, 새로운 상태를 추가(슬라이딩 윈도우)
        win.pop(0)  # 가장 오래된 값 제거
        win.append(next_state)  # 새 계산 결과 추가

    return "SK" if win[-1] else "CY"

n = int(input("돌 개수를 입력하세요: "))

result = can_win_stones(n)
print(result)
